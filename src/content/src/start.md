# Start

This chapter -- Start -- starts you, the Reader, off in reading the rest of this tutorial. Think of it as a "meta introduction" with the real introduction coming in the next chapter.
This meta introduction describes the tactics I've employed in writing this tutorial. Although other chapters will be littered with stage direction throughout, this chapter is almost exclusively stage directions and context setting.
It's one big aside. I hope to keep it short.

So, first, who am I and why am I writing this? I'm a professional software developer with 46 years of professional programming experience at various levels and in various guises. In an industry that seems to actively punish experience (via age),
I have experience in bulk and the scar tissue that goes with it. I'm well aware that the profession has changed dramatically over my tenure -- my first editor was a paper tape punch -- but I've kept abreast of the changes and think I can offer some wisdom 
(no, really!) and perspective on the arc of this history. Programming languages come and go, but the goals and strategies for success evolve more slowly. They _have_ changed, but not as much as that breathless blog post you read this morning would have you
believe.

Every writer has a voice. I have mine. Programming has defined my adult working life. I was taken with it from my very first few programs I blundered through. I've spent many long hours -- some happy some not -- honing my skills and improving my craft.
I've read extensively about it and about topics that surround programming such as Computer Science and Mathematics. I got paid to do it too, can you believe it? Like Donna Summers, I worked hard for the money and I wasn't always treated right. 
But on good days I made things with my own mind and hands and when needed, mastered the tools and techniques to make them well.

I also freely admit I'm a journeyman. There are _many_ who are better developers, faster with results and results that run faster. My mediocrity, however, makes me human. I remember a time when programmers were nerds -- and embraced the irony of it -- not 
Masters of the Universe who were "killin' it" on social media and with venture capitalists. My jealousy notwithstanding -- I'll never own a rowboat, nevermind a yacht -- I take some comfort that programming rewards above all else perseverence. You can always get
after falling down. It requires nothing special except perhaps the absense of common sense.

Second, who are you and why are you reading this? That one's a little harder. Beyond the obvious -- you want to learn how to programming with the Rust programming language -- you have some experience programming in another programming language such as python, typescript or even javascript which, yes, are all interpreted languages generally. You also have some experience with a compiled language like C, C++, zig or go, one that requires a linking step after compilation. This distinction has traditionally been important, but the latest languages have lessened the differences, rust especially.

More importantly, you have the time, discipline and persistence to learn-by-doing and experiment. I'll be your bush guide and I'll even take you off some of the beaten paths. But this is just the beginning of your journey. Along the way I hope you'll learn _fruitful_ ways to experiment. How to break things. How to demonstrate or prove to _yourself_ that something is actually working and working well enough, however you define it. How to organize your programs and visualize your data. Some of you will eventually write tutorials and I'll want to read them.
